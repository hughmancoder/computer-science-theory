@R1
D = M // base address of array
@arr
M = D // store base address in array
@R2
D = M // len of array
@len
M = D 
@i
M = 0
@j
M = 0
(OUTERLOOP)
@len
D = M - 1  // D = len - 1
@i
D = D - M //  len - 1 - i 
@OUTERLOOPEND
D; JLE  // break if i < len - 1
@j 
M = 0
(INNERLOOP)
@len
D = M
@i
D = D - M 
D = D - 1 //D = len - i - 1
@j
D = D - M // j < len - i - 1 ->  len - i - 1 - j > 0 (non jump condition)
@INNERLOOPEND
D; JLE
@arr
D = M
@j
A = M + D  // holds *(base + j)
D = M  // arr[j]
@prev //holds arr[r]
M = D 
@arr
D = M
@j
A = M + D // get address of arr[j]
A = A + 1 // arr[j+1]
D = M // arr[j + 1]
@next
M = D // arr[j + 1]
@prev
D = D - M  // D = arr[j+1] - arr[j] < 0 
@IFEND 
D; JGE
@arr
D = M 
@j
A = M + D 
A = A + 1 // Array[j + 1]
@prev
D = M // arr[j]
@j
M = D // arr[j+1] = arr[j]
@next
D = M // D = arr[j + 1]
@j
A = M - 1 // gets arr[j]
M = D // arr[j] = arr[j+1]




(IFEND)
@INNERLOOP
@j
M = M + 1 // j++
0; JMP
(INNERLOOPEND)
@OUTERLOOP
@i
M = M + 1 // i++
0; JMP
(OUTERLOOPEND)
(END)
@END
0; JMP // jump unconditionallly

